/**
 * @file cc_proto_base.hpp
 * @author llhsdmd (llhsdmd@gmail.com)
 * @brief provide base interface for proto message and proto factory
 *
 * @mainpage ccproto
 *
 * @section intro_sec Introduction
 *
 * ccproto is a c++ library for serialize and deserialize proto message.
 * no external code generator required, more easy to use. but support only c++.
 * If you don't need cross language protocols, this would be a good choice
 *
 * @section usage_sec Usage
 * you need only include this header file, and inherit the ProtoBase, and 
 * use CS_SERIALIZE specify the members you want to serialize.
 * 
 * @section example_sec Example
 * @code {.c++}
 * #include "cc_proto_base.hpp"
 * #include "cc_proto_json_serializer.hpp"
 * #include "cc_serializer_base.hpp"
 *
 * struct ProtoMessage ProtoBase<ProtoMessage> {
 *     int a;
 *     std::string b;
 *
 *     CS_SERIALIZE(a, b)
 * }
 *
 * int main() {
 *     ProtoFactory factory(1, 0, 0);
 *     IProto* msg = factory.create("ProtoMessage");
 *     msg->a = 1;
 *     msg->b = "hello";
 *     std::vector<char> data;
 *     data = msg->toData();
 *     // do something
 *     delete msg;
 *     return 0;
 * }
 * @endcode
 *
 * @section note_sec Note
 * The protocol registered in this protocol library will be assigned
 * a typeId through the dictionary order of the protocol name. You
 * can obtain this ID through the type() method. Since the ID is
 * automatically generated, it is important to pay attention to this
 * when using an ID to interact between different protocol libraries.
 *
 * @par license
 *  GPL-3.0 license
 * @version 0.1
 * @date 2024-05-23
 *
 * @copyright Copyright (c) 2024
 *
 */
#pragma once

#include <cstring>
#include <functional>
#include <map>
#include <vector>

#include "cc_proto_global.hpp"

CS_PROTO_BEGIN_NAMESPACE
class JsonSerializer;
class ProtoFactory;

auto static_init_funcs(const CS_STRING_VIEW&, std::function<void(ProtoFactory*)>)
    -> std::map<CS_STRING_VIEW, std::function<void(ProtoFactory*)>>&;
int type_counter();

class CS_PROTO_API IProto {
public:
    IProto() = default;
    virtual ~IProto() = default;
    /**
     * @brief serializer self
     *
     * @return std::vector<char> the data
     */
    virtual std::vector<char> toData() const = 0;
    /**
     * @brief deserializer self
     * The input data must be serialized using the same serializer as the current one
     * @param[in] data
     * @return true deserialized successfully
     * @return false maybe missing some data or data is invalid
     */
    virtual bool formData(const std::vector<char>&) = 0;
    /**
     * @brief type
     *  This type value is generated by sorting the names of all types
     * registered in the factory in lexicographic order
     * @return int
     */
    virtual int type() const = 0;
    /**
     * @brief proto message class name
     *
     * @return CS_STRING_VIEW is std::string_view after c++17 and std::string before c++14
     */
    virtual CS_STRING_VIEW className() const = 0;
};

template <typename ProtoT, typename SerializerT = JsonSerializer>
class ProtoBase : public IProto {
public:
    using ProtoType = ProtoT;
    using SerializerType = SerializerT;
    using ProtoBaseType = ProtoBase;

    ProtoBase() = default;
    ProtoBase(const ProtoBase& other);
    ProtoBase(ProtoBase&& other);
    virtual ~ProtoBase() = default;
    ProtoBase& operator=(const ProtoBase& other);
    ProtoBase& operator=(ProtoBase&& other);

    std::vector<char> toData() const override;
    int type() const override;
    bool formData(const std::vector<char>& data) override;
    CS_STRING_VIEW className() const override;

private:
    mutable SerializerT mSerializer;
    static CS_STRING_VIEW _init_class_name__;
};

class CS_PROTO_API ProtoFactory {
public:
    ProtoFactory(int major = 0, int minor = 0, int patch = 1);
    ProtoFactory(const ProtoFactory&);
    ProtoFactory(ProtoFactory&&);
    ProtoFactory& operator=(const ProtoFactory&);
    ProtoFactory& operator=(ProtoFactory&&);
    ~ProtoFactory();

    void init();
    template <typename T>
    void regist(const CS_STRING_VIEW& name);
    template <typename T>
    static int proto_type();
    template <typename T>
    static CS_STRING_VIEW proto_name();
    /**
     * @brief create a proto object by type
     *  this object is a pointer, you need to delete it by yourself
     * @param type
     * @return IProto*
     */
    IProto* create(int type) const;
    /**
     * @brief create a proto object by name
     *  this object is a pointer, you need to delete it by yourself
     * @param name
     * @return IProto*
     */
    inline IProto* create(const char* name) const;
    /**
     * @brief create a object
     * this object is a pointer, you need to delete it by yourself
     * @return T*
     */
    template <typename T>
    inline T* create() const;
    uint32_t version() const;

private:
    std::map<int, std::function<IProto*()>> mProtoMap;
    std::map<CS_STRING_VIEW, int> mProtoNameMap;
    uint32_t mVersion = 0;

    template <typename T>
    static IProto* creater();
    void setVersion(int major, int minor, int patch);
};

template <typename T>
void ProtoFactory::regist(const CS_STRING_VIEW& name) {
    auto itemType = mProtoMap.find(proto_type<T>());
    auto itemName = mProtoNameMap.find(name);
    if (itemType != mProtoMap.end()) {
        CS_STRING_VIEW rname = "";
        for (auto item : mProtoNameMap) {
            if (item.second == proto_type<T>()) {
                rname = item.first;
                break;
            }
        }
        CS_LOG_WARN("type {} is regist by proto({}), proto({}) can't regist again", proto_type<T>(), rname, name);
    }
    if (itemName != mProtoNameMap.end()) {
        CS_LOG_WARN("proto({}) is regist type {}, can't regist type {} again", name, itemName->second, proto_type<T>());
    }
    CS_LOG_INFO("Init proto {}:{} for factory({})", name, proto_type<T>(), (void*)this);
    mProtoNameMap.insert(std::make_pair(name, proto_type<T>()));
    mProtoMap.insert(std::make_pair(proto_type<T>(), creater<T>));
}

template <typename T>
int ProtoFactory::proto_type() {
    static int _proto_type = 0;
    if (_proto_type == 0) {
        _proto_type = type_counter();
    }
    return _proto_type;
}

template <typename T>
CS_STRING_VIEW ProtoFactory::proto_name() {
    return _cs_class_name<T>();
}

template <typename T>
T* ProtoFactory::create() const {
    return new T();
}

template <typename T>
IProto* ProtoFactory::creater() {
    return new T();
}

template <typename ProtoT, typename SerializerT>
CS_STRING_VIEW ProtoBase<ProtoT, SerializerT>::_init_class_name__ = []() {
    static_assert(std::is_base_of<ProtoBaseType, ProtoT>::value, "ProtoT must inherit from ProtoBase<ProtoT>");
    CS_STRING_VIEW name = _cs_class_name<ProtoT>();
    static_init_funcs(name, [name](CS_PROTO_NAMESPACE::ProtoFactory* self) { self->regist<ProtoT>(name); });
    return name;
}();

template <typename T, typename SerializerT>
ProtoBase<T, SerializerT>::ProtoBase(const ProtoBase<T, SerializerT>& other) {
    mSerializer = other.mSerializer;
}

template <typename T, typename SerializerT>
ProtoBase<T, SerializerT>::ProtoBase(ProtoBase<T, SerializerT>&& other) {
    mSerializer = std::move(other.mSerializer);
}

template <typename T, typename SerializerT>
ProtoBase<T, SerializerT>& ProtoBase<T, SerializerT>::operator=(const ProtoBase<T, SerializerT>& other) {
    mSerializer = other.mSerializer;
    return *this;
}

template <typename T, typename SerializerT>
ProtoBase<T, SerializerT>& ProtoBase<T, SerializerT>::operator=(ProtoBase<T, SerializerT>&& other) {
    mSerializer = std::move(other.mSerializer);
    return *this;
}

template <typename T, typename SerializerT>
CS_STRING_VIEW ProtoBase<T, SerializerT>::className() const {
    return _init_class_name__;
}

template <typename T, typename SerializerT>
std::vector<char> ProtoBase<T, SerializerT>::toData() const {
    mSerializer.startSerialize();
    auto self = dynamic_cast<const ProtoType*>(this);
    CS_ASSERT(self != nullptr, "please make sure that ProtoBase<{}, {}> is only inherited by {}.", _init_class_name__,
              _cs_class_name<SerializerT>(), _init_class_name__);
    auto ret = const_cast<ProtoType*>(self)->serialize(mSerializer);
    std::vector<char> data;
    if (!mSerializer.endSerialize(&data)) {
        CS_LOG_ERROR("{} serialize error", _init_class_name__);
    }
    return std::move(data);
}

template <typename T, typename SerializerT>
int ProtoBase<T, SerializerT>::type() const {
    return ProtoFactory::proto_type<T>();
}

template <typename T, typename SerializerT>
bool ProtoBase<T, SerializerT>::formData(const std::vector<char>& data) {
    if (!mSerializer.startDeserialize(data)) {
        return false;
    }
    auto self = dynamic_cast<const ProtoType*>(this);
    CS_ASSERT(self != nullptr, "please make sure that ProtoBase<{}, {}> is only inherited by {}.", _init_class_name__,
              _cs_class_name<SerializerT>(), _init_class_name__);
    bool ret = const_cast<ProtoType*>(self)->deserialize(mSerializer);
    if (!mSerializer.endDeserialize() || !ret) {
        CS_LOG_ERROR("{} deserialize error", _init_class_name__);
        return false;
    }
    return true;
}

CS_PROTO_END_NAMESPACE
