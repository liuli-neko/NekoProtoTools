/**
 * @file proto_base.hpp
 * @author llhsdmd (llhsdmd@gmail.com)
 * @brief provide base interface for proto message and proto factory
 *
 * @mainpage NekoProtoTools
 *
 * @section intro_sec Introduction
 *
 * NekoProtoTools is a c++ library for serialize and deserialize proto message.
 * no external code generator required, more easy to use. but support only c++.
 * If you don't need cross language protocols, this would be a good choice
 *
 * @section usage_sec Usage
 * you need only include this header file, and inherit the ProtoBase, and
 * use CS_SERIALIZE specify the members you want to serialize.
 *
 * @section example_sec Example
 * @code {.c++}
 * #include "proto_base.hpp"
 * #include "json_serializer.hpp"
 * #include "serializer_base.hpp"
 *
 * struct ProtoMessage {
 *     int a;
 *     std::string b;
 *
 *     NEKO_SERIALIZE(a, b)
 *     NEKO_DECLARE_PROTOCOL(ProtoMessage, JsonSerializer)
 * }
 *
 * int main() {
 *     ProtoFactory factory(1, 0, 0);
 *     IProto* msg = factory.create("ProtoMessage"); // or auto msg = makeProtocol(ProtoMessage{});
 *     auto raw = msg->cast<ProtoMessage>();
 *     raw->a = 1;
 *     raw->b = "hello";
 *     std::vector<char> data;
 *     data = msg->toData();
 *     // do something
 *     delete msg;
 *     return 0;
 * }
 * @endcode
 *
 * @section note_sec Note
 * The protocol registered in this protocol library will be assigned
 * a typeId through the dictionary order of the protocol name. You
 * can obtain this ID through the type() method. Since the ID is
 * automatically generated, it is important to pay attention to this
 * when using an ID to interact between different protocol libraries.
 *
 * @par license
 *  GPL-2.0 license
 * @version 0.1
 * @date 2024-05-23
 *
 * @copyright Copyright (c) 2024 by llhsdmd
 *
 */
#pragma once

#include <cstring>
#include <functional>
#include <map>
#include <vector>

#include "private/detail/reflection_serializer.hpp"
#include "private/global.hpp"

NEKO_BEGIN_NAMESPACE
class ProtoFactory;

auto static_init_funcs(const NEKO_STRING_VIEW&, std::function<void(ProtoFactory*)>)
    -> std::map<NEKO_STRING_VIEW, std::function<void(ProtoFactory*)>>&;
int type_counter();

class NEKO_PROTO_API IProto {
public:
    IProto()          = default;
    virtual ~IProto() = default;
    /**
     * @brief serializer self
     *
     * @return std::vector<char> the data
     */
    virtual std::vector<char> toData() const NEKO_NOEXCEPT = 0;
    /**
     * @brief deserializer self
     * The input data must be serialized using the same serializer as the current one
     * @param[in] data
     * @return true deserialized successfully
     * @return false maybe missing some data or data is invalid
     */
    virtual bool formData(const std::vector<char>&) NEKO_NOEXCEPT = 0;
    /**
     * @brief type
     *  This type value is generated by sorting the names of all types
     * registered in the factory in lexicographic order
     * @return int
     */
    virtual int type() const NEKO_NOEXCEPT = 0;
    /**
     * @brief proto message name
     *
     * @return NEKO_STRING_VIEW is std::string_view after c++17 and std::string before c++14
     */
    virtual NEKO_STRING_VIEW protoName() const NEKO_NOEXCEPT = 0;

    template <typename T>
    bool getField(const NEKO_STRING_VIEW& name, T* result) NEKO_NOEXCEPT {
        auto reflectionObject = getReflectionObject();
        if (reflectionObject == nullptr) {
            return false;
        }
        return reflectionObject->getField(name, result);
    }

    template <typename T>
    T getField(const NEKO_STRING_VIEW& name, const T& defaultValue) NEKO_NOEXCEPT {
        auto reflectionObject = getReflectionObject();
        NEKO_ASSERT(reflectionObject != nullptr, "reflectionObject is nullptr");
        return reflectionObject->getField(name, defaultValue);
    }

    template <typename T>
    bool setField(const NEKO_STRING_VIEW& name, const T& value) NEKO_NOEXCEPT {
        auto reflectionObject = getReflectionObject();
        NEKO_ASSERT(reflectionObject != nullptr, "reflectionObject is nullptr");
        return reflectionObject->setField(name, value);
    }

    template <typename T>
    T* cast() NEKO_NOEXCEPT;

private:
    virtual detail::ReflectionObject* getReflectionObject() NEKO_NOEXCEPT = 0;

protected:
    virtual void* data() NEKO_NOEXCEPT = 0;
};

template <typename ProtoT, typename SerializerT>
class ProtoBase : public IProto {
public:
    using ProtoType      = ProtoT;
    using SerializerType = SerializerT;
    using ProtoBaseType  = ProtoBase;

    ProtoBase();
    explicit ProtoBase(const ProtoT&);
    explicit ProtoBase(ProtoT&&);
    explicit ProtoBase(ProtoT*);
    ProtoBase(ProtoBase&& other);
    virtual ~ProtoBase();
    ProtoBase& operator=(ProtoBase&& other) NEKO_NOEXCEPT;
    ProtoBase& operator=(const ProtoT& other) NEKO_NOEXCEPT;
    ProtoBase& operator=(ProtoT&& other) NEKO_NOEXCEPT;

    ProtoT& operator*() NEKO_NOEXCEPT { return *mData; }
    ProtoT* operator->() NEKO_NOEXCEPT { return mData; }
    const ProtoT& operator*() const NEKO_NOEXCEPT { return *mData; }
    const ProtoT* operator->() const NEKO_NOEXCEPT { return mData; }
    operator const ProtoT&() const NEKO_NOEXCEPT { return *mData; }
    operator ProtoT&() NEKO_NOEXCEPT { return *mData; }

    std::vector<char> toData() const NEKO_NOEXCEPT override;
    int type() const NEKO_NOEXCEPT override;
    bool formData(const std::vector<char>& data) NEKO_NOEXCEPT override;
    NEKO_STRING_VIEW protoName() const NEKO_NOEXCEPT override;
    static NEKO_STRING_VIEW name() NEKO_NOEXCEPT;
    static std::vector<char> Serialize(const ProtoT& proto);
    static bool Deserialize(const std::vector<char>& data, ProtoT& proto);

protected:
    inline detail::ReflectionObject* getReflectionObject() NEKO_NOEXCEPT override;
    ProtoBase(const ProtoBase& other)            = delete;
    ProtoBase& operator=(const ProtoBase& other) = delete;
    virtual void* data() NEKO_NOEXCEPT override;

private:
    std::unique_ptr<detail::ReflectionSerializer> mReflectionSerializer = {};
    ProtoT* mData                                                       = {};
    bool mIsNew                                                         = false;
    static NEKO_STRING_VIEW kProtoName;
};

class NEKO_PROTO_API ProtoFactory {
public:
    explicit ProtoFactory(int major = 0, int minor = 0, int patch = 1);
    ~ProtoFactory();

    template <typename T>
    void regist(const NEKO_STRING_VIEW& name) NEKO_NOEXCEPT;
    void regist(const NEKO_STRING_VIEW& name, std::function<IProto*()> creator) NEKO_NOEXCEPT;
    template <typename T>
    static int proto_type() NEKO_NOEXCEPT;
    template <typename T>
    static NEKO_STRING_VIEW proto_name() NEKO_NOEXCEPT;
    /**
     * @brief create a proto object by type
     *  this object is a pointer, you need to delete it by yourself
     * @param type
     * @return std::unique_ptr<IProto>
     */
    std::unique_ptr<IProto> create(int type) const NEKO_NOEXCEPT;
    /**
     * @brief create a proto object by name
     *  this object is a pointer, you need to delete it by yourself
     * @param name
     * @return IProto*
     */
    std::unique_ptr<IProto> create(const char* name) const NEKO_NOEXCEPT;
    uint32_t version() const NEKO_NOEXCEPT;

private:
    ProtoFactory& operator=(const ProtoFactory&) = delete;
    ProtoFactory& operator=(ProtoFactory&&)      = delete;
    void init() NEKO_NOEXCEPT;
    template <typename T>
    static IProto* creater() NEKO_NOEXCEPT;
    void setVersion(int major, int minor, int patch) NEKO_NOEXCEPT;
    static int proto_type(const NEKO_STRING_VIEW& name, const bool isDeclared = false) NEKO_NOEXCEPT;

private:
    std::vector<std::function<IProto*()>> mCreaterList;
    uint32_t mVersion;
};

template <typename T>
void ProtoFactory::regist(const NEKO_STRING_VIEW& name) NEKO_NOEXCEPT {
    regist(name, creater<T>);
}

template <typename T>
int ProtoFactory::proto_type() NEKO_NOEXCEPT {
    return proto_type(proto_name<T>(), false);
}

template <typename T>
NEKO_STRING_VIEW ProtoFactory::proto_name() NEKO_NOEXCEPT {
    return decltype(T::makeProto(std::declval<T>()))::name();
}

template <typename T>
IProto* ProtoFactory::creater() NEKO_NOEXCEPT {
    return new T();
}

template <typename ProtoT, typename SerializerT>
NEKO_STRING_VIEW ProtoBase<ProtoT, SerializerT>::kProtoName = []() NEKO_NOEXCEPT {
    NEKO_STRING_VIEW name = _class_name<ProtoT>();
    static_init_funcs(name, [name](NEKO_NAMESPACE::ProtoFactory* self) { self->regist<ProtoBaseType>(name); });
    return name;
}();

template <typename T>
inline T* IProto::cast() NEKO_NOEXCEPT {
    if (type() == ProtoFactory::proto_type<T>()) {
        return reinterpret_cast<T*>(data());
    }
    return nullptr;
}
template <typename ProtoT, typename SerializerT>
inline void* ProtoBase<ProtoT, SerializerT>::data() NEKO_NOEXCEPT {
    return (void*)(mData);
}

template <typename ProtoT, typename SerializerT>
inline ProtoBase<ProtoT, SerializerT>::ProtoBase() : mData(new ProtoT()), mIsNew(true) {}

template <typename ProtoT, typename SerializerT>
inline ProtoBase<ProtoT, SerializerT>::ProtoBase(const ProtoT& p) : mData(new ProtoT(p)), mIsNew(true) {}

template <typename ProtoT, typename SerializerT>
inline ProtoBase<ProtoT, SerializerT>::ProtoBase(ProtoT&& p) : mData(new ProtoT(std::move(p))), mIsNew(true) {}

template <typename ProtoT, typename SerializerT>
inline ProtoBase<ProtoT, SerializerT>::ProtoBase(ProtoT* p) : mData(p), mIsNew(false) {}

template <typename T, typename SerializerT>
ProtoBase<T, SerializerT>::ProtoBase(ProtoBase<T, SerializerT>&& other) {
    mReflectionSerializer = std::move(other.mReflectionSerializer);
    mData                 = std::move(other.mData);
    mIsNew                = other.mIsNew;
    other.mIsNew          = false;
    other.mData           = nullptr;
}

template <typename ProtoT, typename SerializerT>
inline ProtoBase<ProtoT, SerializerT>::~ProtoBase() {
    if (mIsNew) {
        delete mData;
    }
}

template <typename T, typename SerializerT>
ProtoBase<T, SerializerT>& ProtoBase<T, SerializerT>::operator=(ProtoBase<T, SerializerT>&& other) NEKO_NOEXCEPT {
    mReflectionSerializer = std::move(other.mReflectionSerializer);
    mData                 = std::move(other.mData);
    mIsNew                = other.mIsNew;
    other.mIsNew          = false;
    other.mData           = nullptr;
    return *this;
}

template <typename ProtoT, typename SerializerT>
inline ProtoBase<ProtoT, SerializerT>& ProtoBase<ProtoT, SerializerT>::operator=(const ProtoT& other) NEKO_NOEXCEPT {
    (*mData) = other;
    return *this;
}

template <typename ProtoT, typename SerializerT>
inline ProtoBase<ProtoT, SerializerT>& ProtoBase<ProtoT, SerializerT>::operator=(ProtoT&& other) NEKO_NOEXCEPT {
    (*mData) = std::move(other);
    return *this;
}

template <typename T, typename SerializerT>
NEKO_STRING_VIEW ProtoBase<T, SerializerT>::protoName() const NEKO_NOEXCEPT {
    return kProtoName;
}

template <typename T, typename SerializerT>
NEKO_STRING_VIEW ProtoBase<T, SerializerT>::name() NEKO_NOEXCEPT {
    return kProtoName;
}

template <typename ProtoT, typename SerializerT>
inline detail::ReflectionObject* ProtoBase<ProtoT, SerializerT>::getReflectionObject() NEKO_NOEXCEPT {
    NEKO_ASSERT(mData != nullptr, "mData is nullptr");
    if (mReflectionSerializer != nullptr) {
        return mReflectionSerializer->getObject();
    }
    mReflectionSerializer.reset(new detail::ReflectionSerializer());
    bool ret = mData->serialize(*mReflectionSerializer);
    NEKO_ASSERT(ret, "{} get reflection object error", kProtoName);
    NEKO_ASSERT(mReflectionSerializer->getObject() != nullptr, "mReflectionSerializer->getObject() is nullptr");
    return mReflectionSerializer->getObject();
}

template <typename ProtoT, typename SerializerT>
std::vector<char> ProtoBase<ProtoT, SerializerT>::Serialize(const ProtoT& proto) {
    std::vector<char> data;
    typename SerializerT::OutputSerializer serializer(data);
    auto ret = serializer(proto);
    if (!serializer.end()) {
        NEKO_LOG_ERROR("{} serialize error", kProtoName);
    }
    return data;
}

template <typename ProtoT, typename SerializerT>
bool ProtoBase<ProtoT, SerializerT>::Deserialize(const std::vector<char>& data, ProtoT& proto) {
    typename SerializerT::InputSerializer serializer(data.data(), data.size());
    if (!serializer) {
#if defined(NEKO_VERBOSE_LOGS)
        NEKO_LOG_INFO("{} data parser failed.", kProtoName);
#endif
        return false;
    }
    bool ret = serializer(proto);
    if (!ret) {
        NEKO_LOG_ERROR("{} deserialize error", kProtoName);
        return false;
    }
    return true;
}

template <typename T, typename SerializerT>
std::vector<char> ProtoBase<T, SerializerT>::toData() const NEKO_NOEXCEPT {
    NEKO_ASSERT(mData != nullptr, "mData is nullptr");
    return Serialize(*mData);
}

template <typename T, typename SerializerT>
int ProtoBase<T, SerializerT>::type() const NEKO_NOEXCEPT {
    return ProtoFactory::proto_type<T>();
}

template <typename T, typename SerializerT>
bool ProtoBase<T, SerializerT>::formData(const std::vector<char>& data) NEKO_NOEXCEPT {
    NEKO_ASSERT(mData != nullptr, "mData is nullptr");
    return Deserialize(data, *mData);
}

#define NEKO_DECLARE_PROTOCOL(className, Serializer)                                                                   \
public:                                                                                                                \
    using ProtoType = typename NEKO_NAMESPACE::ProtoBase<className, Serializer>;                                       \
    /** @brief make proto from self pointer */                                                                         \
    inline ProtoType makeProto() NEKO_NOEXCEPT { return ProtoType(this); }                                             \
    /** @brief make proto with structure */                                                                            \
    template <typename... Args>                                                                                        \
    inline static ProtoType emplaceProto(Args&&... args) NEKO_NOEXCEPT {                                               \
        static_assert(std::is_move_constructible<className>::value, "class " #className " must be copable");           \
        return ProtoType(className{std::forward<Args>(args)...});                                                      \
    }                                                                                                                  \
    /** @brief make proto by copying other */                                                                          \
    inline static ProtoType makeProto(const className& other) NEKO_NOEXCEPT {                                          \
        static_assert(std::is_copy_constructible<className>::value, "class " #className " must be copable");           \
        return ProtoType(other);                                                                                       \
    }

NEKO_END_NAMESPACE
