/**
 * @file proto_base.hpp
 * @author llhsdmd (llhsdmd@gmail.com)
 * @brief provide base interface for proto message and proto factory
 *
 * @mainpage NekoProtoTools
 *
 * @section intro_sec Introduction
 *
 * NekoProtoTools is a c++ library for serialize and deserialize proto message.
 * no external code generator required, more easy to use. but support only c++.
 * If you don't need cross language protocols, this would be a good choice
 *
 * @section usage_sec Usage
 * you need only include this header file, and inherit the ProtoBase, and
 * use CS_SERIALIZE specify the members you want to serialize.
 *
 * @section example_sec Example
 * @code {.c++}
 * #include "proto_base.hpp"
 * #include "json_serializer.hpp"
 * #include "serializer_base.hpp"
 *
 * struct ProtoMessage {
 *     int a;
 *     std::string b;
 *
 *     NEKO_SERIALIZE(a, b)
 *     NEKO_DECLARE_PROTOCOL(ProtoMessage, JsonSerializer)
 * }
 *
 * int main() {
 *     ProtoFactory factory(1, 0, 0);
 *     IProto msg = factory.create("ProtoMessage"); // or auto msg = ProtoMessage::emplaceProto({});
 *     auto* raw = msg.cast<ProtoMessage>();
 *     raw->a = 1;
 *     raw->b = "hello";
 *     std::vector<char> data;
 *     data = msg.toData();
 *     // do something
 *     delete msg;
 *     return 0;
 * }
 * @endcode
 *
 * @section note_sec Note
 * The protocol registered in this protocol library will be assigned
 * a typeId through the dictionary order of the protocol name. You
 * can obtain this ID through the type() method. Since the ID is
 * automatically generated, it is important to pay attention to this
 * when using an ID to interact between different protocol libraries.
 *
 * @par license
 *  GPL-2.0 license
 * @version 0.1
 * @date 2024-05-23
 *
 * @copyright Copyright (c) 2024 by llhsdmd
 *
 */
#pragma once

#include <cstring>
#include <functional>
#include <map>
#include <unordered_map>
#include <vector>

#include "nekoproto/global/global.hpp"
#include "nekoproto/global/reflect.hpp"
#include "private/proto_base_private.hpp"

#define NEKO_RESERVED_PROTO_TYPE_SIZE 64

NEKO_BEGIN_NAMESPACE
class NEKO_PROTO_API ProtoFactory;
namespace detail {
NEKO_PROTO_API
auto static_init_funcs(const NEKO_STRING_VIEW&, std::function<void(ProtoFactory*)>)
    -> std::map<NEKO_STRING_VIEW, std::function<void(ProtoFactory*)>>&;
} // namespace detail

class IProto {
public:
    IProto() = default;
    explicit IProto(detail::AbstractProto* proto);
    IProto(IProto&& proto);
    ~IProto() = default;
    /**
     * @brief serializer self
     *
     * @return std::vector<char> the data
     */
    inline std::vector<char> toData() const NEKO_NOEXCEPT;
    inline bool toData(std::vector<char>& buffer) const NEKO_NOEXCEPT;
    /**
     * @brief deserializer self
     * The input data must be serialized using the same serializer as the current one
     * @param[in] data
     * @return true deserialized successfully
     * @return false maybe missing some data or data is invalid
     */
    inline bool fromData(const char* data, std::size_t size) NEKO_NOEXCEPT;
    /**
     * @brief type
     *  This type value is generated by sorting the names of all types
     * registered in the factory in lexicographic order
     * @return int
     */
    inline int type() const NEKO_NOEXCEPT;
    /**
     * @brief proto message name
     * This name is the same as the class name
     * @return NEKO_STRING_VIEW is std::string_view after c++17 and std::string before c++14
     */
    inline NEKO_STRING_VIEW protoName() const NEKO_NOEXCEPT;
    /**
     * @brief clone
     *  This method is used to clone the current object, and the clone object
     * @return IProto
     */
    inline IProto clone() const;
    /**
     * @brief Get the Field object
     *  use the member name to get the field, only support nameValuePair field.
     * @tparam T
     * @param name the field name in nameValuePair in serializer
     * @param result the field value, the type must be the same as the field type
     * @return true if the field exists, otherwise false
     * @return false field not exists or field type is not the same as the result type
     */
    template <typename T>
    bool getField(const NEKO_STRING_VIEW& name, T* result) NEKO_NOEXCEPT;
    template <typename T>
    T getField(const NEKO_STRING_VIEW& name, const T& defaultValue) NEKO_NOEXCEPT;
    template <typename T>
    bool setField(const NEKO_STRING_VIEW& name, const T& value) NEKO_NOEXCEPT;
    template <typename T>
    T* cast() NEKO_NOEXCEPT;
    template <typename T>
    const T* cast() const NEKO_NOEXCEPT;

    bool operator==(std::nullptr_t) const;
    template <typename T>
    bool operator==(T* ptr) const;
    template <typename T, typename std::enable_if<!std::is_same<T, IProto>::value, char>::type = '0'>
    IProto& operator=(const T& proto);
    IProto& operator=(IProto&& proto);

private:
    std::unique_ptr<detail::AbstractProto> mImp;
};

class NEKO_PROTO_API ProtoFactory {
public:
    explicit ProtoFactory(int major = 0, int minor = 0, int patch = 1);
    ~ProtoFactory();

    template <typename T>
    void regist(const NEKO_STRING_VIEW& name) NEKO_NOEXCEPT;
    void regist(const NEKO_STRING_VIEW& name, std::function<IProto()> creator) NEKO_NOEXCEPT;
    static const std::map<NEKO_STRING_VIEW, int>& protoTypeMap() NEKO_NOEXCEPT;
    template <typename T>
    static int protoType() NEKO_NOEXCEPT;
    template <typename T>
    static int specifyProtoType(int type) NEKO_NOEXCEPT;
    template <typename T>
    static NEKO_STRING_VIEW protoName() NEKO_NOEXCEPT;
    /**
     * @brief create a proto object by type
     *  this object is a pointer, you need to delete it by yourself
     * @param type
     * @return IProto
     */
    IProto create(int type) const NEKO_NOEXCEPT;
    /**
     * @brief create a proto object by name
     *  this object is a pointer, you need to delete it by yourself
     * @param name
     * @return IProto
     */
    IProto create(const char* name) const NEKO_NOEXCEPT;
    uint32_t version() const NEKO_NOEXCEPT;

private:
    ProtoFactory& operator=(const ProtoFactory&) = delete;
    ProtoFactory& operator=(ProtoFactory&&)      = delete;
    void _init() NEKO_NOEXCEPT;
    template <typename T>
    static IProto _creater() NEKO_NOEXCEPT;
    void _setVersion(int major, int minor, int patch) NEKO_NOEXCEPT;
    static int _protoType(const NEKO_STRING_VIEW& name, bool isDeclared = false, int specifyType = -1) NEKO_NOEXCEPT;
    static std::map<NEKO_STRING_VIEW, int>& _staticProtoTypeMap();

private:
    std::vector<std::function<IProto()>> mCreaterList;
    std::unordered_map<int, std::function<IProto()>> mDynamicCreaterMap;
    uint32_t mVersion;
};

template <typename T>
void ProtoFactory::regist(const NEKO_STRING_VIEW& name) NEKO_NOEXCEPT {
    regist(name, _creater<T>);
}
template <typename T>
int ProtoFactory::specifyProtoType(const int type) NEKO_NOEXCEPT {
    return _protoType(protoName<T>(), true, type);
}

template <typename T>
int ProtoFactory::protoType() NEKO_NOEXCEPT {
    static int kType = -1;
    if (kType == -1) NEKO_IF_UNLIKELY {
            kType = _protoType(protoName<T>(), false);
        }
    return kType;
}

template <typename T>
NEKO_STRING_VIEW ProtoFactory::protoName() NEKO_NOEXCEPT {
    const auto& name = T::ProtoType::name();
    if (name.empty()) NEKO_IF_UNLIKELY {
            return detail::class_nameof<T>;
        }
    return name;
}

template <typename T>
IProto ProtoFactory::_creater() NEKO_NOEXCEPT {
    return IProto{new T()};
}

inline IProto::IProto(detail::AbstractProto* proto) : mImp(proto) {}

inline IProto::IProto(IProto&& proto) : mImp(std::move(proto.mImp)) {}

inline std::vector<char> IProto::toData() const NEKO_NOEXCEPT {
    if (mImp) {
        return mImp->toData();
    }
    return {};
}

inline bool IProto::toData(std::vector<char>& buffer) const NEKO_NOEXCEPT {
    if (mImp) {
        return mImp->toData(buffer);
    }
    return false;
}

inline bool IProto::fromData(const char* data, std::size_t size) NEKO_NOEXCEPT {
    if (mImp) {
        return mImp->fromData(data, size);
    }
    return false;
}

inline int IProto::type() const NEKO_NOEXCEPT {
    if (mImp) {
        return mImp->type();
    }
    return -1;
}

inline NEKO_STRING_VIEW IProto::protoName() const NEKO_NOEXCEPT {
    if (mImp) {
        return mImp->protoName();
    }
    return "IProto";
}

inline IProto IProto::clone() const {
    if (mImp) {
        return IProto{mImp->clone()};
    }
    return {};
}

template <typename T>
bool IProto::getField(const NEKO_STRING_VIEW& name, T* result) NEKO_NOEXCEPT {
    NEKO_ASSERT(mImp != nullptr, "ReflectionSerializer", " protoobject is nullptr");
    auto* reflectionObject = mImp->getReflectionObject();
    if (reflectionObject == nullptr) {
        return false;
    }
    return reflectionObject->getField(name, result);
}

template <typename T>
T IProto::getField(const NEKO_STRING_VIEW& name, const T& defaultValue) NEKO_NOEXCEPT {
    NEKO_ASSERT(mImp != nullptr, "ReflectionSerializer", "proto object is nullptr");
    auto* reflectionObject = mImp->getReflectionObject();
    NEKO_ASSERT(reflectionObject != nullptr, "ReflectionSerializer", "reflectionObject is nullptr");
    return reflectionObject->getField(name, defaultValue);
}

template <typename T>
bool IProto::setField(const NEKO_STRING_VIEW& name, const T& value) NEKO_NOEXCEPT {
    NEKO_ASSERT(mImp != nullptr, "ReflectionSerializer", "proto object is nullptr");
    auto* reflectionObject = mImp->getReflectionObject();
    NEKO_ASSERT(reflectionObject != nullptr, "ReflectionSerializer", "reflectionObject is nullptr");
    return reflectionObject->setField(name, value);
}

inline bool IProto::operator==(std::nullptr_t) const { return mImp == nullptr; }
template <typename T>
bool IProto::operator==(T* ptr) const {
    if (mImp == nullptr && mImp->data() == ptr) {
        return true;
    }
    auto self = cast<T>();
    if (mImp->data() != nullptr && self != nullptr) {
        return *ptr == *self;
    }
    return false;
}
template <typename T, typename std::enable_if<!std::is_same<T, IProto>::value, char>::type>
inline IProto& IProto::operator=(const T& proto) {
    if (mImp) {
        auto self = cast<T>();
        if (self != nullptr) {
            *self = proto;
        }
    }
    return *this;
}

inline IProto& IProto::operator=(IProto&& proto) {
    mImp = std::move(proto.mImp);
    return *this;
}

template <typename T>
inline T* IProto::cast() NEKO_NOEXCEPT {
    if (mImp && type() == ProtoFactory::protoType<T>()) {
        return reinterpret_cast<T*>(mImp->data());
    }
    return nullptr;
}

template <typename T>
const T* IProto::cast() const NEKO_NOEXCEPT {
    if (mImp && type() == ProtoFactory::protoType<T>()) {
        return reinterpret_cast<const T*>(mImp->data());
    }
    return nullptr;
}

namespace detail {
template <typename T, typename SerializerT>
int ProtoBase<T, SerializerT>::type() const NEKO_NOEXCEPT {
    return ProtoFactory::protoType<T>();
}
template <typename ProtoT, class enable = void>
struct declared_specify_type { // NOLINT
    static void declared() {}
};
template <typename ProtoT>
struct declared_specify_type<ProtoT, typename std::enable_if<has_method_specify_type<ProtoT, int>::value>::type> {
    static void declared() NEKO_NOEXCEPT {
        auto ret = ProtoFactory::specifyProtoType<ProtoT>(proto_method_access::static_method_specify_type<ProtoT>());
        NEKO_ASSERT(ret != -1, "proto", "type declaration failed");
    }
};

template <typename ProtoT, typename SerializerT>
NEKO_STRING_VIEW ProtoBase<ProtoT, SerializerT>::gProtoName = []() NEKO_NOEXCEPT {
    NEKO_STRING_VIEW name = class_nameof<ProtoT>;
    declared_specify_type<ProtoT>::declared();
    static_init_funcs(name, [name](NEKO_NAMESPACE::ProtoFactory* self) { self->regist<ProtoBaseType>(name); });
    return name;
}();

} // namespace detail

#define NEKO_DECLARE_PROTOCOL(className, Serializer)                                                                   \
public:                                                                                                                \
    using ProtoType = typename NEKO_NAMESPACE::detail::ProtoBase<className, Serializer>;                               \
    /** @brief make proto from self pointer */                                                                         \
    inline NEKO_NAMESPACE::IProto makeProto() NEKO_NOEXCEPT { return NEKO_NAMESPACE::IProto{new ProtoType(this)}; }    \
    /** @brief make proto with structure */                                                                            \
    template <typename... Args>                                                                                        \
    inline static NEKO_NAMESPACE::IProto emplaceProto(Args&&... args) NEKO_NOEXCEPT {                                  \
        static_assert(std::is_move_constructible<className>::value, "class " #className " must be copable");           \
        return NEKO_NAMESPACE::IProto{new ProtoType(className{std::forward<Args>(args)...})};                          \
    }                                                                                                                  \
    /** @brief make proto by copying other */                                                                          \
    inline static NEKO_NAMESPACE::IProto makeProto(const className& other) NEKO_NOEXCEPT {                             \
        static_assert(std::is_copy_constructible<className>::value, "class " #className " must be copable");           \
        return NEKO_NAMESPACE::IProto{new ProtoType(other)};                                                           \
    }

NEKO_END_NAMESPACE
